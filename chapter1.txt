--- Python numerical types ----
Decimal type: based on the IBM General Decimal Arithmetic Specification
Fraction type: stores two integers, the numerator and the denominator
Complex type: 

--- Basic mathematical functions ---
math: 
- sqrt, sin, cos, tan, pi, asin, acos, atan
- gamma: gamma function
- erf: Gaussian error function
- comb: math.comb(5, 2) -> 10
- factorial: math.factorial(5) -> 120 <=> 5!
- gcd: greatest common divisor 
- fsum: 
-  floor and ceil

--- NumPy arrays ---
NumPy arrays must consist of homogeneous data (all elements have the same type)

arr[::] => [start:stop:step]

dtype
astype

np.linspace(0, 1, 5) # array([0., 0.25, 0.5, 0.75, 1.0])
np.arange(0, 1, 0.3) # array([0.0, 0.3, 0.6, 0.9])

shape
reshape

-- Matrices

- The transposition reverses the order of the shape of a matrix (array)
mat.transpose()
mat.T

- multiplication
A = np.array([[1, 2], [3, 4]])
B = np.array([[-1, 1], [0, 1]])
A @ B
# array([[-1, 3],
#        [-3, 7]])
A * B # different from A @ B
# array([[-1, 2],
# [ 0, 4]])

- Determinants and inverses
from numpy import linalg

linalg.det(A) # -2.0000000000000004 -> Determinants
linalg.inv(A) -> inverse

- Systems of equations
linalg.solve

-- Eigenvalues and eigenvectors
v, B = linalg.eig(A)    -> return type complex32 or complex64
i = 0                   # first eigenvalue/eigenvector pair
lambda0 = v[i]          => 6.823156164525971
x0 = B[:, i]            # ith column of B => # array([ 0.73271846, -0.20260301, 0.649672352])
linalg.norm(x0)         # 1.0 - eigenvectors are normalized.
lhs = A @ x0
rhs = lambda0*x0
linalg.norm(lhs - rhs)  # 2.8435583831733384e-15 - very small.
(the left-hand side 'lhs' and the right-hand side 'rhs')